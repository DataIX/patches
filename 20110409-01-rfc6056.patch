# HG changeset patch
# Parent 0b64756243b94c04d600cc450c79a94e9f8a5bec
RFC6506 stable/8 r220504, Supercedes: 20110303-01-rfc6056.patch

diff -r 0b64756243b9 sys/netinet/in_pcb.c
--- a/sys/netinet/in_pcb.c
+++ b/sys/netinet/in_pcb.c
@@ -36,12 +36,14 @@
 
 #include "opt_ddb.h"
 #include "opt_ipsec.h"
+#include "opt_inet.h"
 #include "opt_inet6.h"
 
 #include <sys/param.h>
 #include <sys/systm.h>
 #include <sys/malloc.h>
 #include <sys/mbuf.h>
+#include <sys/md5.h>	
 #include <sys/domain.h>
 #include <sys/protosw.h>
 #include <sys/socket.h>
@@ -73,6 +75,7 @@
 #ifdef INET6
 #include <netinet/ip6.h>
 #include <netinet6/ip6_var.h>
+#include <netinet6/in6_pcb.h>
 #endif /* INET6 */
 
 
@@ -84,6 +87,15 @@
 #include <security/mac/mac_framework.h>
 
 /*
+ * RFC6056 Port Randomization Algorithms.
+ */
+#define	INP_RFC6056_ALG_1 1	/* Simple Port Randomization Algorithm I */
+#define	INP_RFC6056_ALG_2 2	/* Simple Port Randomization Algorithm II */
+#define	INP_RFC6056_ALG_3 3	/* Simple Hash-Based Port Selection Algorithm */
+#define	INP_RFC6056_ALG_4 4	/* Double-Hash Port Selection Algorithm */
+#define	INP_RFC6056_ALG_5 5	/* Random-Increments Port Selection Algorithm */
+
+/*
  * These configure the range of local port addresses assigned to
  * "unspecified" outgoing connections/packets/whatever.
  */
@@ -110,7 +122,14 @@
 VNET_DEFINE(int, ipport_tcpallocs);
 static VNET_DEFINE(int, ipport_tcplastcount);
 
+static VNET_DEFINE(u_int, ipport_randomalg_ver) = INP_RFC6056_ALG_1;
+						/* user controlled via sysctl */
+static VNET_DEFINE(u_int, ipport_randomalg_alg5_tradeoff) = 500;
+						/* user controlled via sysctl */
+
 #define	V_ipport_tcplastcount		VNET(ipport_tcplastcount)
+#define V_ipport_randomalg_ver		VNET(ipport_randomalg_ver)
+#define V_ipport_randomalg_alg5_tradeoff VNET(ipport_randomalg_alg5_tradeoff)
 
 #define RANGECHK(var, min, max) \
 	if ((var) < (min)) { (var) = (min); } \
@@ -141,7 +160,66 @@
 
 #undef RANGECHK
 
+/*
+ * Updates algorithm to use for random ephemeral port (local) port allocation
+ * in in_pcbbind_setup() / in_pcb_lport().
+ */
+static int
+sysctl_net_randomalg_version_check(SYSCTL_HANDLER_ARGS)
+{
+	u_int algorithm;
+	int error;
+
+	algorithm = *(u_int *)arg1;
+#ifdef VIMAGE
+	error = vnet_sysctl_handle_uint(oidp, &algorithm, 0, req);
+#else
+	error = sysctl_handle_int(oidp, &algorithm, 0, req);
+#endif
+	if (error == 0 && req->newptr) {
+		switch (algorithm) {
+		case INP_RFC6056_ALG_1:
+		case INP_RFC6056_ALG_2:
+		case INP_RFC6056_ALG_3:
+		case INP_RFC6056_ALG_4:
+		case INP_RFC6056_ALG_5:
+			V_ipport_randomalg_ver = algorithm;
+			break;
+		default:
+			return (EINVAL);
+		}
+	} 	
+	return (error);
+}
+
+/*
+ * Updates V_ipport_randomalg_alg5_tradeoff to provided value
+ * and ensures it is in the supported range (1 - 65536).
+ */
+static int
+sysctl_net_randomalg_alg5_tradeoff_check(SYSCTL_HANDLER_ARGS)
+{
+	u_int tradeoff;
+	int error;
+
+	tradeoff = *(u_int *)arg1;
+#ifdef VIMAGE
+	error = vnet_sysctl_handle_uint(oidp, &tradeoff, 0, req);
+#else
+	error = sysctl_handle_int(oidp, &tradeoff, 0, req);
+#endif
+	if (error == 0 && req->newptr) {
+		if (tradeoff < 1 || tradeoff > 65536)
+			return (EINVAL);
+		else
+			V_ipport_randomalg_alg5_tradeoff = tradeoff;
+	}
+	return (error);
+}
+
 SYSCTL_NODE(_net_inet_ip, IPPROTO_IP, portrange, CTLFLAG_RW, 0, "IP Ports");
+SYSCTL_NODE(_net_inet_ip_portrange, IPPROTO_IP, randomalg, CTLFLAG_RW, 0, 
+	"Port Randomization Algorithms");
 
 SYSCTL_VNET_PROC(_net_inet_ip_portrange, OID_AUTO, lowfirst,
 	CTLTYPE_INT|CTLFLAG_RW, &VNET_NAME(ipport_lowfirstauto), 0,
@@ -174,6 +252,14 @@
 	&VNET_NAME(ipport_randomtime), 0,
 	"Minimum time to keep sequental port "
 	"allocation before switching to a random one");
+SYSCTL_VNET_PROC(_net_inet_ip_portrange_randomalg, OID_AUTO, version,
+	CTLTYPE_UINT|CTLFLAG_RW, &VNET_NAME(ipport_randomalg_ver), 0,
+	&sysctl_net_randomalg_version_check, "IU", 
+	"RFC 6056 Port randomization algorithm");
+SYSCTL_VNET_PROC(_net_inet_ip_portrange_randomalg, OID_AUTO, alg5_tradeoff,
+	CTLTYPE_UINT|CTLFLAG_RW, &VNET_NAME(ipport_randomalg_alg5_tradeoff), 0,
+	&sysctl_net_randomalg_alg5_tradeoff_check, "IU",
+	"RFC 6056 Algorithm 5 computational trade-off");
 
 /*
  * in_pcb.c: manage the Protocol Control Blocks.
@@ -271,6 +357,397 @@
 	return (0);
 }
 
+#if defined(INET) || defined(INET6)
+int
+in_pcb_lport(struct inpcb *inp, struct in_addr *laddrp, u_short *lportp,
+    struct ucred *cred, int wild)
+{
+	struct inpcbinfo *pcbinfo;
+	struct inpcb *tmpinp;
+	unsigned short *lastport;
+	int count, dorandom, error;
+	unsigned short aux, first, last, lport;
+#ifdef INET
+	struct in_addr laddr;
+#endif
+
+	pcbinfo = inp->inp_pcbinfo;
+
+	/*
+	 * Because no actual state changes occur here, a global write lock on
+	 * the pcbinfo isn't required.
+	 */
+	INP_INFO_LOCK_ASSERT(pcbinfo);
+	INP_LOCK_ASSERT(inp);
+
+	if (inp->inp_flags & INP_HIGHPORT) {
+		first = V_ipport_hifirstauto;	/* sysctl */
+		last  = V_ipport_hilastauto;
+		lastport = &pcbinfo->ipi_lasthi;
+	} else if (inp->inp_flags & INP_LOWPORT) {
+		error = priv_check_cred(cred,
+		    PRIV_NETINET_RESERVEDPORT, 0);
+		if (error)
+			return (error);
+		first = V_ipport_lowfirstauto;	/* 1023 */
+		last  = V_ipport_lowlastauto;	/* 600 */
+		lastport = &pcbinfo->ipi_lastlow;
+	} else {
+		first = V_ipport_firstauto;	/* sysctl */
+		last  = V_ipport_lastauto;
+		lastport = &pcbinfo->ipi_lastport;
+	}
+	/*
+	 * For UDP, use random port allocation as long as the user
+	 * allows it.  For TCP (and as of yet unknown) connections,
+	 * use random port allocation only if the user allows it AND
+	 * ipport_tick() allows it.
+	 */
+	if (V_ipport_randomized &&
+	    (!V_ipport_stoprandom || pcbinfo == &V_udbinfo))
+		dorandom = 1;
+	else
+		dorandom = 0;
+	/*
+	 * It makes no sense to do random port allocation if
+	 * we have the only port available.
+	 */
+	if (first == last)
+		dorandom = 0;
+	/* Make sure to not include UDP packets in the count. */
+	if (pcbinfo != &V_udbinfo)
+		V_ipport_tcpallocs++;
+	/*
+	 * Instead of having two loops further down counting up or down
+	 * make sure that first is always <= last and go with only one
+	 * code path implementing all logic.
+	 */
+	if (first > last) {
+		aux = first;
+		first = last;
+		last = aux;
+	}
+
+	count = last - first;
+
+#ifdef INET
+	if ((inp->inp_vflag & INP_IPV4) != 0) {
+		KASSERT(laddrp != NULL, ("%s: laddrp NULL for v4 inp %p",
+		    __func__, inp));
+		laddr = *laddrp;
+	}
+#endif
+	lport = *lportp;
+
+	/* 
+	 * RFC 6056 specifies five possible algorithms for random port
+	 * allocation.  We allow the user to change which one to use by sysctl.
+	 */
+	if (dorandom) {
+
+		switch (V_ipport_randomalg_ver) {
+
+		/* Random-Increments Port Selection. */
+		case INP_RFC6056_ALG_5:
+		do {
+			if (count-- < 0)	/* completely used? */
+				return (EADDRNOTAVAIL);
+
+			*lastport = first + ((arc4random() % 65536) + 
+			    (arc4random() % V_ipport_randomalg_alg5_tradeoff) +
+			    1);
+
+			if (*lastport < first || *lastport > last)
+				*lastport = first;
+			lport = htons(*lastport);
+
+#ifdef INET6
+			if ((inp->inp_vflag & INP_IPV6) != 0)
+				tmpinp = in6_pcblookup_local(pcbinfo,
+				    &inp->in6p_laddr, lport, wild, cred);
+#endif
+#if defined(INET) && defined(INET6)
+			else
+#endif
+#ifdef INET
+				tmpinp = in_pcblookup_local(pcbinfo,
+				    laddr, lport, wild, cred);
+#endif
+		} while (tmpinp != NULL);
+		break;
+
+		/* Double-Hash Port Selection Algorithm. */
+		case INP_RFC6056_ALG_4:
+		{
+			MD5_CTX f_ctx;
+			MD5_CTX g_ctx;
+			u_int32_t F[4] = { 0, 0, 0, 0 };
+			u_int32_t G[4] = { 0, 0, 0, 0 };
+			u_int32_t secret_f[4] = { 0, 0, 0, 0 };
+			u_int32_t secret_g[4] = { 0, 0, 0, 0 };
+			u_int16_t table[16]; 
+			u_int32_t index = 0;
+			u_int32_t offset = 0;
+
+			secret_f[0] = arc4random();
+			secret_f[1] = arc4random();
+			secret_f[2] = arc4random();
+			secret_f[3] = arc4random();
+
+			secret_g[0] = arc4random();
+			secret_g[1] = arc4random();
+			secret_g[2] = arc4random();
+			secret_g[3] = arc4random();
+
+			for (index = 0; index < sizeof(table); index++)
+				table[index] = arc4random() % 65536;
+
+			MD5Init(&f_ctx);
+#ifdef INET6
+			if ((inp->inp_vflag & INP_IPV6) != 0) {
+				MD5Update(&f_ctx, (u_char *)&inp->in6p_laddr,
+				    sizeof(inp->in6p_laddr));
+				MD5Update(&f_ctx, (u_char *)&inp->in6p_faddr,
+				    sizeof(inp->in6p_faddr));
+			}
+#endif
+#if defined(INET) && defined(INET6)
+			else
+#endif
+#ifdef INET
+			{
+				MD5Update(&f_ctx, (u_char *)&inp->inp_laddr,
+				    sizeof(inp->inp_laddr));
+				MD5Update(&f_ctx, (u_char *)&inp->inp_faddr,
+				    sizeof(inp->inp_faddr));
+			}
+#endif
+			MD5Update(&f_ctx, (u_char *)&inp->inp_fport,
+			    sizeof(inp->inp_fport));
+			MD5Update(&f_ctx, (u_char *)secret_f,
+			    sizeof(secret_f));
+			MD5Final((u_char *)&F, &f_ctx);
+
+			offset = ((F[0] ^ F[1]) ^ (F[2] ^ F[3]));
+
+			MD5Init(&g_ctx);
+#ifdef INET6
+			if ((inp->inp_vflag & INP_IPV6) != 0) {
+				MD5Update(&g_ctx, (u_char *)&inp->in6p_laddr,
+				    sizeof(inp->in6p_laddr));
+				MD5Update(&g_ctx, (u_char *)&inp->in6p_faddr,
+				    sizeof(inp->in6p_faddr));
+			}
+#endif
+#if defined(INET) && defined(INET6)
+			else
+#endif
+#ifdef INET
+			{
+				MD5Update(&g_ctx, (u_char *)&inp->inp_laddr,
+				    sizeof(inp->inp_laddr));
+				MD5Update(&g_ctx, (u_char *)&inp->inp_faddr,
+				    sizeof(inp->inp_faddr));
+			}
+#endif
+			MD5Update(&g_ctx, (u_char *)&inp->inp_fport,
+			    sizeof(inp->inp_fport));
+			MD5Update(&g_ctx, (u_char *)secret_g,
+			    sizeof(secret_g));
+			MD5Final((u_char *)&G, &g_ctx);
+
+			index = ((G[0] ^ G[1]) ^ (G[2] ^ G[3])) % sizeof(table);
+
+			do {
+				if (count-- < 0)	/* completely used? */
+					return (EADDRNOTAVAIL);
+
+				*lastport = first + 
+				    (offset + table[index]++) % count;
+
+				if (*lastport < first || *lastport > last)
+					*lastport = first;
+				lport = htons(*lastport);
+
+#ifdef INET6
+			if ((inp->inp_vflag & INP_IPV6) != 0)
+				tmpinp = in6_pcblookup_local(pcbinfo,
+				    &inp->in6p_laddr, lport, wild, cred);
+#endif
+#if defined(INET) && defined(INET6)
+			else
+#endif
+#ifdef INET
+				tmpinp = in_pcblookup_local(pcbinfo,
+				    laddr, lport, wild, cred);
+#endif
+			} while (tmpinp != NULL);
+		}
+		break;
+
+
+		/* Simple Hash-Based Port Selection Algorithm. */
+		case INP_RFC6056_ALG_3:
+		{
+			MD5_CTX f_ctx;
+			u_int32_t F[4] = { 0, 0, 0, 0 };
+			u_int32_t secret_f[4] = { 0, 0, 0, 0 };
+			u_int32_t offset = 0;
+
+			secret_f[0] = arc4random();
+			secret_f[1] = arc4random();
+			secret_f[2] = arc4random();
+			secret_f[3] = arc4random();
+
+			MD5Init(&f_ctx);
+#ifdef INET6
+			if ((inp->inp_vflag & INP_IPV6) != 0) {
+				MD5Update(&f_ctx, (u_char *)&inp->in6p_laddr,
+				    sizeof(inp->in6p_laddr));
+				MD5Update(&f_ctx, (u_char *)&inp->in6p_faddr,
+				    sizeof(inp->in6p_faddr));
+			}
+#endif
+#if defined(INET) && defined(INET6)
+			else
+#endif
+#ifdef INET
+			{
+				MD5Update(&f_ctx, (u_char *)&inp->inp_laddr,
+				    sizeof(inp->inp_laddr));
+				MD5Update(&f_ctx, (u_char *)&inp->inp_faddr,
+				    sizeof(inp->inp_faddr));
+			}
+#endif
+			MD5Update(&f_ctx, (u_char *)&inp->inp_fport,
+			    sizeof(inp->inp_fport));
+			MD5Update(&f_ctx, (u_char *)secret_f,
+			    sizeof(secret_f));
+			MD5Final((u_char *)&F, &f_ctx);
+
+			offset = ((F[0] ^ F[1]) ^ (F[2] ^ F[3]));
+
+			do {
+				if (count-- < 0)	/* completely used? */
+					return (EADDRNOTAVAIL);
+
+				*lastport = first + ((arc4random() % 65536) + 
+				    (offset % 65536)) % count;
+
+				if (*lastport < first || *lastport > last)
+					*lastport = first;
+				lport = htons(*lastport);
+
+#ifdef INET6
+			if ((inp->inp_vflag & INP_IPV6) != 0)
+				tmpinp = in6_pcblookup_local(pcbinfo,
+				    &inp->in6p_laddr, lport, wild, cred);
+#endif
+#if defined(INET) && defined(INET6)
+			else
+#endif
+#ifdef INET
+				tmpinp = in_pcblookup_local(pcbinfo,
+				    laddr, lport, wild, cred);
+#endif
+			} while (tmpinp != NULL);
+		}
+		break;
+
+		/* Simple Port Randomization Algorithm II. */
+		case INP_RFC6056_ALG_2:
+		do {
+			if (count-- < 0)	/* completely used? */
+				return (EADDRNOTAVAIL);
+
+			*lastport = first +
+			    (arc4random() % (last - first));
+
+			if (*lastport < first || *lastport > last)
+				*lastport = first;
+			lport = htons(*lastport);
+
+#ifdef INET6
+			if ((inp->inp_vflag & INP_IPV6) != 0)
+				tmpinp = in6_pcblookup_local(pcbinfo,
+				    &inp->in6p_laddr, lport, wild, cred);
+#endif
+#if defined(INET) && defined(INET6)
+			else
+#endif
+#ifdef INET
+				tmpinp = in_pcblookup_local(pcbinfo,
+				    laddr, lport, wild, cred);
+#endif
+		} while (tmpinp != NULL);
+		break;
+
+
+		/* Simple Port Randomization Algorithm I. */
+		case INP_RFC6056_ALG_1:
+		default:
+			*lastport = first + (arc4random() % (last - first));
+
+			do {
+				if (count-- < 0)	/* completely used? */
+					return (EADDRNOTAVAIL);
+
+				++*lastport;
+
+				if (*lastport < first || *lastport > last)
+					*lastport = first;
+				lport = htons(*lastport);
+
+#ifdef INET6
+				if ((inp->inp_vflag & INP_IPV6) != 0)
+					tmpinp = in6_pcblookup_local(pcbinfo,
+					   &inp->in6p_laddr, lport, wild, cred);
+#endif
+#if defined(INET) && defined(INET6)
+				else
+#endif
+#ifdef INET
+					tmpinp = in_pcblookup_local(pcbinfo,
+					    laddr, lport, wild, cred);
+#endif
+			} while (tmpinp != NULL);
+		} /* switch() */
+	} else {
+		do {
+			if (count-- < 0)        /* completely used? */
+				return (EADDRNOTAVAIL);
+
+			++*lastport;
+
+			if (*lastport < first || *lastport > last)
+				*lastport = first;
+			lport = htons(*lastport);
+
+#ifdef INET6
+			if ((inp->inp_vflag & INP_IPV6) != 0)
+				tmpinp = in6_pcblookup_local(pcbinfo,
+				    &inp->in6p_laddr, lport, wild, cred);
+#endif
+#if defined(INET) && defined(INET6)
+			else
+#endif
+#ifdef INET
+				tmpinp = in_pcblookup_local(pcbinfo,
+				    laddr, lport, wild, cred);
+#endif
+		} while (tmpinp != NULL);
+	}
+
+#ifdef INET
+	if ((inp->inp_vflag & INP_IPV4) != 0)
+		laddrp->s_addr = laddr.s_addr;
+#endif
+	*lportp = lport;
+
+	return (0);
+}
+#endif /* INET || INET6 */
+
 /*
  * Set up a bind operation on a PCB, performing port allocation
  * as required, but do not actually modify the PCB. Callers can
@@ -285,14 +762,12 @@
     u_short *lportp, struct ucred *cred)
 {
 	struct socket *so = inp->inp_socket;
-	unsigned short *lastport;
 	struct sockaddr_in *sin;
 	struct inpcbinfo *pcbinfo = inp->inp_pcbinfo;
 	struct in_addr laddr;
 	u_short lport = 0;
 	int wild = 0, reuseport = (so->so_options & SO_REUSEPORT);
 	int error;
-	int dorandom;
 
 	/*
 	 * Because no actual state changes occur here, a global write lock on
@@ -417,72 +892,9 @@
 	if (*lportp != 0)
 		lport = *lportp;
 	if (lport == 0) {
-		u_short first, last, aux;
-		int count;
-
-		if (inp->inp_flags & INP_HIGHPORT) {
-			first = V_ipport_hifirstauto;	/* sysctl */
-			last  = V_ipport_hilastauto;
-			lastport = &pcbinfo->ipi_lasthi;
-		} else if (inp->inp_flags & INP_LOWPORT) {
-			error = priv_check_cred(cred,
-			    PRIV_NETINET_RESERVEDPORT, 0);
-			if (error)
-				return error;
-			first = V_ipport_lowfirstauto;	/* 1023 */
-			last  = V_ipport_lowlastauto;	/* 600 */
-			lastport = &pcbinfo->ipi_lastlow;
-		} else {
-			first = V_ipport_firstauto;	/* sysctl */
-			last  = V_ipport_lastauto;
-			lastport = &pcbinfo->ipi_lastport;
-		}
-		/*
-		 * For UDP, use random port allocation as long as the user
-		 * allows it.  For TCP (and as of yet unknown) connections,
-		 * use random port allocation only if the user allows it AND
-		 * ipport_tick() allows it.
-		 */
-		if (V_ipport_randomized &&
-			(!V_ipport_stoprandom || pcbinfo == &V_udbinfo))
-			dorandom = 1;
-		else
-			dorandom = 0;
-		/*
-		 * It makes no sense to do random port allocation if
-		 * we have the only port available.
-		 */
-		if (first == last)
-			dorandom = 0;
-		/* Make sure to not include UDP packets in the count. */
-		if (pcbinfo != &V_udbinfo)
-			V_ipport_tcpallocs++;
-		/*
-		 * Instead of having two loops further down counting up or down
-		 * make sure that first is always <= last and go with only one
-		 * code path implementing all logic.
-		 */
-		if (first > last) {
-			aux = first;
-			first = last;
-			last = aux;
-		}
-
-		if (dorandom)
-			*lastport = first +
-				    (arc4random() % (last - first));
-
-		count = last - first;
-
-		do {
-			if (count-- < 0)	/* completely used? */
-				return (EADDRNOTAVAIL);
-			++*lastport;
-			if (*lastport < first || *lastport > last)
-				*lastport = first;
-			lport = htons(*lastport);
-		} while (in_pcblookup_local(pcbinfo, laddr,
-		    lport, wild, cred));
+		error = in_pcb_lport(inp, &laddr, &lport, cred, wild);
+		if (error != 0)
+			return (error);
 	}
 	*laddrp = laddr.s_addr;
 	*lportp = lport;
diff -r 0b64756243b9 sys/netinet/in_pcb.h
--- a/sys/netinet/in_pcb.h
+++ b/sys/netinet/in_pcb.h
@@ -486,6 +486,8 @@
 void	in_pcbpurgeif0(struct inpcbinfo *, struct ifnet *);
 int	in_pcballoc(struct socket *, struct inpcbinfo *);
 int	in_pcbbind(struct inpcb *, struct sockaddr *, struct ucred *);
+int	in_pcb_lport(struct inpcb *, struct in_addr *, u_short *,
+	    struct ucred *, int);
 int	in_pcbbind_setup(struct inpcb *, struct sockaddr *, in_addr_t *,
 	    u_short *, struct ucred *);
 int	in_pcbconnect(struct inpcb *, struct sockaddr *, struct ucred *);
diff -r 0b64756243b9 sys/netinet6/in6_src.c
--- a/sys/netinet6/in6_src.c
+++ b/sys/netinet6/in6_src.c
@@ -108,6 +108,8 @@
 #include <netinet6/scope6_var.h>
 #include <netinet6/nd6.h>
 
+#include <sys/md5.h>
+
 static struct mtx addrsel_lock;
 #define	ADDRSEL_LOCK_INIT()	mtx_init(&addrsel_lock, "addrsel_lock", NULL, MTX_DEF)
 #define	ADDRSEL_LOCK()		mtx_lock(&addrsel_lock)
@@ -850,9 +852,11 @@
 in6_pcbsetport(struct in6_addr *laddr, struct inpcb *inp, struct ucred *cred)
 {
 	struct socket *so = inp->inp_socket;
-	u_int16_t lport = 0, first, last, *lastport;
-	int count, error, wild = 0, dorandom;
+	u_int16_t lport = 0;
+	int error, wild = 0;
+#ifdef INVARIANTS
 	struct inpcbinfo *pcbinfo = inp->inp_pcbinfo;
+#endif
 
 	INP_INFO_WLOCK_ASSERT(pcbinfo);
 	INP_WLOCK_ASSERT(inp);
@@ -868,71 +872,13 @@
 
 	inp->inp_flags |= INP_ANONPORT;
 
-	if (inp->inp_flags & INP_HIGHPORT) {
-		first = V_ipport_hifirstauto;	/* sysctl */
-		last  = V_ipport_hilastauto;
-		lastport = &pcbinfo->ipi_lasthi;
-	} else if (inp->inp_flags & INP_LOWPORT) {
-		error = priv_check_cred(cred, PRIV_NETINET_RESERVEDPORT, 0);
-		if (error)
-			return error;
-		first = V_ipport_lowfirstauto;	/* 1023 */
-		last  = V_ipport_lowlastauto;	/* 600 */
-		lastport = &pcbinfo->ipi_lastlow;
-	} else {
-		first = V_ipport_firstauto;	/* sysctl */
-		last  = V_ipport_lastauto;
-		lastport = &pcbinfo->ipi_lastport;
-	}
-
 	/*
-	 * For UDP, use random port allocation as long as the user
-	 * allows it.  For TCP (and as of yet unknown) connections,
-	 * use random port allocation only if the user allows it AND
-	 * ipport_tick() allows it.
+	 * XXX-BZ we have not used *laddr here before, was that a day one
+	 * bug for at least on of the udp6_output() cases?
 	 */
-	if (V_ipport_randomized &&
-	    (!V_ipport_stoprandom || pcbinfo == &V_udbinfo))
-		dorandom = 1;
-	else
-		dorandom = 0;
-	/*
-	 * It makes no sense to do random port allocation if
-	 * we have the only port available.
-	 */
-	if (first == last)
-		dorandom = 0;
-	/* Make sure to not include UDP packets in the count. */
-	if (pcbinfo != &V_udbinfo)
-		V_ipport_tcpallocs++;
-
-	/*
-	 * Instead of having two loops further down counting up or down
-	 * make sure that first is always <= last and go with only one
-	 * code path implementing all logic.
-	 */
-	if (first > last) {
-		u_int16_t aux;
-
-		aux = first;
-		first = last;
-		last = aux;
-	}
-
-	if (dorandom)
-		*lastport = first + (arc4random() % (last - first));
-
-	count = last - first;
-
-	do {
-		if (count-- < 0)	/* completely used? */
-			return (EADDRNOTAVAIL);
-		++*lastport;
-		if (*lastport < first || *lastport > last)
-			*lastport = first;
-		lport = htons(*lastport);
-	} while (in6_pcblookup_local(pcbinfo, &inp->in6p_laddr,
-	    lport, wild, cred));
+	error = in_pcb_lport(inp, NULL, &lport, cred, wild);
+	if (error != 0)
+		return (error);
 
 	inp->inp_lport = lport;
 	if (in_pcbinshash(inp) != 0) {
